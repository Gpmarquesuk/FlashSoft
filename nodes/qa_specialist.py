import json
import os
import subprocess
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Optional

from router import Router


@dataclass
class QAResult:
    command: list[str]
    stdout: str
    stderr: str
    overlay_path: Path
    artifact_path: Path
    transcript_path: Path
    report_path: Path


class FunctionalQAFailed(RuntimeError):
    pass


def _detect_cli(repo_path: Path) -> Optional[list[str]]:
    if (repo_path / "interview_assistant" / "__main__.py").exists():
        return [sys.executable, "-m", "interview_assistant"]
    if (repo_path / "src" / "interview_assistant" / "__main__.py").exists():
        return [sys.executable, "-m", "src.interview_assistant"]
    if (repo_path / "src" / "interview_assistant.py").exists():
        return [sys.executable, "-m", "src.interview_assistant"]
    return None


def _ensure_sample_files(repo_path: Path) -> tuple[Path, Path, Path]:
    manual_dir = repo_path / "examples" / "manual_inputs"
    resume = manual_dir / "Resume-Gustavo-Marques Sep25.docx"
    jd = manual_dir / "Technical Application &amp_ Integration Specialist .pdf"
    audio = manual_dir / "captura_wasapi_autodetect.wav"
    if resume.exists() and jd.exists() and audio.exists():
        return resume, jd, audio
    legacy_resume = repo_path / "data" / "resume.json"
    legacy_jd = repo_path / "data" / "jd.md"
    if legacy_resume.exists() and legacy_jd.exists():
        raise FunctionalQAFailed(
            "Manual input samples not found. Expected files in examples/manual_inputs (resume, JD, WAV)."
        )
    raise FunctionalQAFailed("Required sample files not found for QA run.")


def run_functional_qa(
    router: Router,
    repo_path: str,
    question: str = "Why should we hire you?",
) -> QAResult:
    repo = Path(repo_path).resolve()
    command = _detect_cli(repo)
    if not command:
        raise FunctionalQAFailed("Could not locate interview assistant CLI entrypoint.")

    resume, jd, audio = _ensure_sample_files(repo)

    env = os.environ.copy()
    env.setdefault("PYTHONPATH", str(repo))

    qa_run_dir = repo / "artifacts" / "qa_tmp"
    qa_run_dir.mkdir(parents=True, exist_ok=True)
    qa_logs_dir = qa_run_dir / "logs"
    qa_logs_dir.mkdir(parents=True, exist_ok=True)

    cmd = command + [
        "--resume",
        str(resume),
        "--jd",
        str(jd),
        "--question",
        question,
        "--output-dir",
        str(qa_run_dir),
        "--logs-dir",
        str(qa_logs_dir),
        "--audio-file",
        str(audio),
        "--auto-from-audio",
        "--headless-overlay",
        "--audio-chunk-duration",
        "2.0",
    ]

    proc = subprocess.run(
        cmd,
        cwd=repo,
        env=env,
        capture_output=True,
        text=True,
        timeout=180,
    )
    if proc.returncode != 0:
        raise FunctionalQAFailed(f"CLI returned non-zero exit code {proc.returncode}: {proc.stderr}")

    overlay_path = qa_run_dir / "overlay.html"
    artifact_path = qa_run_dir / "last_answer.json"
    transcript_path = qa_logs_dir / "live_transcript.jsonl"
    if not overlay_path.exists():
        raise FunctionalQAFailed("overlay.html was not generated by the CLI.")
    if not artifact_path.exists():
        raise FunctionalQAFailed("last_answer.json was not generated by the CLI.")
    if not transcript_path.exists():
        raise FunctionalQAFailed("live_transcript.jsonl was not generated by the CLI.")

    _validate_outputs(artifact_path, transcript_path)

    report_body = _build_report(router, command=cmd, stdout=proc.stdout, stderr=proc.stderr)
    report_path = repo / "QA_REPORT.md"
    report_path.write_text(report_body, encoding="utf-8")

    return QAResult(
        command=cmd,
        stdout=proc.stdout,
        stderr=proc.stderr,
        overlay_path=overlay_path,
        artifact_path=artifact_path,
        transcript_path=transcript_path,
        report_path=report_path,
    )


def _validate_outputs(artifact_path: Path, transcript_path: Path) -> None:
    try:
        artifact = json.loads(artifact_path.read_text(encoding="utf-8"))
    except json.JSONDecodeError as exc:
        raise FunctionalQAFailed(f"last_answer.json is not valid JSON: {exc}")

    final_answer = artifact.get("final_answer", "").strip()
    if not final_answer:
        raise FunctionalQAFailed("final_answer is empty.")
    if len(final_answer.split()) > 45:
        raise FunctionalQAFailed("final_answer exceeds 45 words.")

    lines = transcript_path.read_text(encoding="utf-8").splitlines()
    utterances = [json.loads(line) for line in lines if line.strip()]
    if not any(chunk.get("text", "").strip() for chunk in utterances):
        raise FunctionalQAFailed("Transcription log contains no spoken content.")


def _build_report(router: Router, command: list[str], stdout: str, stderr: str) -> str:
    system_prompt = (
        "You are a QA specialist for a realtime interview assistant. "
        "Review the CLI execution details and produce a concise Markdown report "
        "with sections: Summary, Observations, Risks, Next Steps."
    )
    payload = {
        "command": command,
        "stdout": stdout.strip(),
        "stderr": stderr.strip(),
    }
    user_prompt = (
        "Execution transcript:\n"
        + json.dumps(payload, ensure_ascii=False, indent=2)
        + "\nRespond in Markdown."
    )
    try:
        return router.call("qa", system_prompt, user_prompt, max_completion=600)
    except Exception:
        basic_report = [
            "# QA Report",
            "## Summary",
            "Executed CLI successfully.",
            "## Observations",
            "```\n" + stdout.strip() + "\n```",
            "## Risks",
            stderr.strip() or "None observed.",
            "## Next Steps",
            "- Manual review recommended.",
        ]
        return "\n".join(basic_report)
